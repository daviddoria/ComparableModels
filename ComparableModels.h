#ifndef COMPARABLEMODELS_H
#define COMPARABLEMODELS_H

#include <ModelFile/ModelFile.h>

#include <LidarScan/LidarScanner.h>
#include <KDTree/KDTree.h>

void display(const ModelFile &Model);
void LookAt();

enum PointType { GOOD, BAD, UNINFORMATIVE, MISS };

class ComparableModels
{
/*
	//inputs: a point cloud of world points from a single scan and a model file 
	after a Create() function is run, access matching points by
	Comparable.World.Points[UsedWorldPoints[i]]
	and
	Comparable.MatchingModelPoints[i]
*/
private:
	//unsigned int Width, Height;
	
public:
	//constructors
	//ComparableModels(const ModelFile &WorldInput, const ModelFile &ModelInput, const LidarScanner &ScannerIn);
	ComparableModels(const ModelFile &WorldInput, const ModelFile &ModelInput);
	void Init(void); //you must call this before using anything else !!!
			
	//Member variables
	unsigned int NumPoints;
	unsigned int MissPoints;
	unsigned int ModelNumber;
	
	LidarScanner Scanner;
	bool ShowProgress_;
	bool Valid_;
	ModelFile World, Model;
	KDTree ModelTree;
	
	std::vector<unsigned int> UsedWorldPoints; //indexes into the World point vector
	std::vector<OrientedPoint> MatchingModelPoints; //these points are generated by intersections, so they are not indices into an existing set of points
	
	std::vector<vgl_point_3d<double> > GetMatchingWorldPoints(void)
	{
		std::vector<vgl_point_3d<double> > Points;
		for(unsigned int i = 0; i < MatchingModelPoints.size(); i++)
		{
			Points.push_back(World.getCoord(UsedWorldPoints[i]));
		}
		return Points;
	}

	std::vector<vgl_point_3d<double> > GetMatchingModelPoints(void)
	{
		std::vector<vgl_point_3d<double> > Points;
		for(unsigned int i = 0; i < MatchingModelPoints.size(); i++)
		{
			Points.push_back(MatchingModelPoints[i].getCoord());
		}
		return Points;
	}

	//functions
	vgl_point_3d<double> GetMatchingModelPoint(unsigned int i)
	{
		return MatchingModelPoints[i].getCoord();
	}
	
	vgl_point_3d<double> GetMatchingWorldCoord(unsigned int i)
	{
		return World.getCoord(UsedWorldPoints[i]);
	}
	
	OrientedPoint GetMatchingWorldPoint(unsigned int i)
	{
		return World.getPoint(UsedWorldPoints[i]);
	}
	
	vector<PointType> PointTypes;
	
	//the number of each of these type of points
	unsigned int TotalPoints() const {return NumPoints + MissPoints;} //an accessor alias
	
	
	unsigned int GoodPoints() const; //points that fall within the threshold
	unsigned int BadPoints() const; //points that are hidden space violations
	unsigned int UninformativePoints() const; //points that are possible occluders
	//unsigned int MissPoints() const; //points in the world that do not intersect the model
	
	void WriteMatchingPoints(const string &WorldFilename, const string &ModelFilename);
	void WriteConnectingLines(const std::string &LineFilename, const double mismatch);
	void CreateOpenGL();
	void CreateUsingOctree();
	
	ModelFile ColorOriginalModel(const double allowance);
	
};

std::ostream& operator<<(std::ostream& output, const ComparableModels &Comparable);


#endif
